import math
from typing import List
import networkx as nx
from collections import defaultdict

from traindsms.dsms.network import NetworkBaseClass
from traindsms.params import LONParams

VERBOSE = True


class LON(NetworkBaseClass):
    """
    co-occurrence graph, generated by joining sub-graphs, made of consecutively ordered words, at shared words
    """

    def __init__(self,
                 params: LONParams,
                 seq_tok: List[List[str]],
                 ):
        NetworkBaseClass.__init__(self)

        self.params = params
        self.seq_tok = seq_tok

        self.sr_bank = {}  # for caching sr scores

    def train(self):

        # ---------------------------------
        # collect edges and nodes

        network_edges = []
        network_nodes = []
        for seq in self.seq_tok:

            edges = []
            for n, token in enumerate(seq):

                # get token at n + 1
                try:
                    token_np1 = seq[n + 1]
                except IndexError:
                    pass
                else:
                    edge = (token, token_np1)
                    edges.append(edge)

                if self.params.context_size != 2:
                    continue

                # get token at n + 2
                try:
                    token_np2 = seq[n + 2]
                except IndexError:
                    pass
                else:
                    edge = (token, token_np2)
                    edges.append(edge)

            network_edges.extend(edges)
            network_nodes.extend(seq)

        self.node_list = list(set(network_nodes))

        # ---------------------------------
        # weight edges

        edge2count = {}
        for edge in network_edges:
            if edge in edge2count:
                edge2count[edge] = edge2count[edge] + 1
            else:
                edge2count[edge] = 1

        weighted_network_edge = []
        for edge in edge2count:
            weighted_network_edge.append(edge + (math.log10(edge2count[edge] + 1),))

        if VERBOSE:
            print()
            print('Weighted Edges:')
            for edge in weighted_network_edge:
                print(self.node_list.index(edge[0]), self.node_list.index(edge[1]), edge)
            print()

        # ---------------------------------
        # make network

        self.network = nx.Graph()
        self.network.add_weighted_edges_from(weighted_network_edge)

    def calc_sr_scores(self, verb, theme, instruments):
        """compute sr scores for a single row in the blank sr data frame."""

        if verb not in self.sr_bank:
            self.sr_bank[verb] = self.activation_spreading_analysis(verb, instruments, [])
        if theme not in self.sr_bank:
            self.sr_bank[theme] = self.activation_spreading_analysis(theme, instruments, [])

        scores = []
        for instrument in instruments:  # instrument columns start after the 3rd column
            sr = math.log(self.sr_bank[verb][instrument] * self.sr_bank[theme][instrument])
            scores.append(sr)

        return scores

    def get_performance(self):
        return {}
